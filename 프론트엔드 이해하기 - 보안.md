# 프론트엔드 이해하기 - 보안

*본 기사는 [Bartosz Szczeciński](https://medium.com/@baphemot?source=post_page-----4963d35feea7----------------------)의 "[Understanding frontend — security]()" (2018. 09. 23 Medium)을 번역한 기사입니다.*

<br/>

![PLEASE CLOSE GATE](http://www.itv.com/news/meridian/2016-04-25/simons-blog-funny-signs/)

출처 :  http://www.itv.com/news/meridian/2016-04-25/simons-blog-funny-signs/

<br/>

프론트 엔드에서 보안은 다음과 같이 두 가지 목적으로 나누어 집니다:

- 클라이언트와 클라이언트의 데이터를 안전하게 유지하기
- 클라이언트를 클라이언트가 접근해서는 안되는 것에서 멀리 떨어트려 놓기

첫 번째 목적은 cross-site-scripting (XSS), cross-site-request-forgery (CSRF), CORS 그리고 브라우저가 어떻게 공격자로 부터 데이터 유출을 막는지, 혹은 공격자가 사칭하여 특정 작업을 시도하는 행위를 막는 것과 같은 다양한 주제를 아우릅니다. 



두 번째 목적은 "나의 사이트 특정 부분에 대한 사용자 접근을 제한하는 방법"에 관한 것입니다. -- 회원에 한하여 접근 가능한 섹션이나, 관리자 패널 같은 것들 말이죠.

<br/>

## 브라우저안의 변수들은 안전할까요?

아마 가장 먼저 드는 생각은 "isAdmin 변수를 만들고 관리자가 인증할 때 마다 true로 설정한 다음 어플리케이션에서 확인할거야"일지도 모릅니다.

하지만 위의 방법대로 한다면 다음과 같은 의문점이 하나 생길겁니다. "만약에 사용자가 개발자 도구를 열고 isAdmin 변수를 true로 바꾸면 어쩌지? 그걸 어떻게 막을 수 있을까? localStorage나 sessionStorage 사용해야되나... 아니, 더 안전한 방법은 없을까?"라고 말이죠.

한 가지 분명히 짚고 넘어가야할 점이 있습니다. 클라이언트 브라우저에 있는 모든 것들은 클라이언트가 손쉽게 변경할 수 있다는 것이죠. 기본적으로 브라우저는 공격자가 필요한 모든 도구를 가지고 있습니다. 공격자는 개발도구를 열고 메모리에 모든 있는 변수를 변경할 수 있습니다. localStorage, sessionStorage, cookies는 물론, 적절한 확장 기능을 이용해서 React 컴포넌트 상태를 변경할 수도 있습니다. 또 인증과 관련된 엔드포인트 응답을 조작해서 매번 { isAdmin: true }을 응답하도록 만들 수도 있습니다.

몇몇 인코딩 폼을 사용할 수 있다고 생각이 드실겁니다. 예를 들어, 직접 배포하거나 혹은 브라우저에서 수정 사항을 확인할 수 있게 JWT를 사용하는 방법들 말이죠. 하지만 이 방법들에도 결함이 있습니다. 왜냐하면 서명을 생성하기 위해서 사용되는 메커니즘 (keys)을 브라우저 역시 인지할 필요성이 있기 때문입니다. -- 아니면 공격자가 자신만의 키를 만들어서 JWT에서 isAdmin을 자신이 만든 키로 바꾼 후 서명하면 됩니다. -- 공격자가 만든 키를 사용해서 유효한 서명으로 인증되면 브라우저는 JWT를 타당한 것으로 간주하고 사용자(공격자)가 관리자라고 인지하게 됩니다.

<br/>

## 사용자를 사이트 내 비공개 부분에 접근하지 못하도록 만드는 방법은 무엇일까요?

지금까지 하던대로 하시면 됩니다. -- 변수를 생성하고, 관리자인 경우에만 true로 설정하여 인증을 통과하면, 관리자만 내용을 볼 수 있도록 말이죠.

여러분은 "그 방법은 전혀 안전하지 않아. -- 모든 사람이 관리자 페이지에가서 전부 지워버릴 수 있잖아!"라고 소리지를지도 모릅니다.

맞아요. -- 물론 적절하지 않은 방법으로 어플리케이션을 구현할 때만 말이죠. 프론트엔드는 유효성이나 제공받은 인증서와 무관해야 합니다. 무슨말이냐면, 프론트엔드에서는 언제나 데이터를 "true"로써 받아들이고 그냥 전달 받은 모든 데이터를 렌더링해야 한다는 의미입니다.

결국 유효성에 관련한 것들은 백엔드에서 다루어야 한다는 것이죠!

여러분의 사이트 UI에 "데이터베이스 삭제하기"버튼이 있다고 가정해봅시다. 여러분은 어떤 로직을 사용해서 그 버튼을 숨기려고 하겠지만, 공격자는 자바스크립트 코드를 다운받아서 모든 엔드포인트를 확인할 수 있습니다. -- 예를 들어 http://example.com/api/database/delete (이 URL은 예제를 위해서만 사용되고, 여러분은 항상 CRUD 표기법을 사용해야 합니다 :) ) URL 같은 것들 말이죠. 그리고 이 URL을 인위적으로 호출 할 겁니다. 이 작업으로 데이터베이스가 삭제된다면 -- 반드시 애플리케이션 보안을 강화해야 합니다.

비슷한 맥락으로, 여러분의 어플리케이션이 /members/blogpost/read-up-on-all-the-new-things를 통해서 회원 전용 컨텐츠를 렌더한다고 가정해보죠. -- 공격자는 직접 그 URL을 통해 컨텐츠를 탐색할 수 있습니다. 만일 공격자가 컨텐츠를 볼 수 있다면, 이는 여러분의 API (혹은 다른 형태의 컨텐츠 전달 형태)는 적절하게 디자인되지 않았다는 의미입니다. -- 컨텐츠 대신에 공격자를 /sign-up으로 바로 리디렉션하거나, 이 방법이 안되는 경우에는 컨텐츠가 없는 블로그 게시물 템플릿을 표시하게끔 해야 합니다.

<br/>

## 결정은 백엔드에게 맡기세요.

앞서 살펴본 두 가지 상황 모두에서 공격자가 차단된 컨텐츠에 침입할 수 있지만, 동작과 관련된 작업을 하는 것은 불가능합니다. 모든 것들은 백엔드와 통신해야하며 어떠한 형태의 인증과 권한 부여 메커니즘울 포함해야 합니다.

동작이 허용된다면, 그 동작을 수행하고 적절한 HTTP 코드(예를 들면, 200)로 응답하면 됩니다. 허용되지 않는다면, 401(인증 되지 않음)이나 403(권한 없음) HTTP 에러 코드로 응답하여야 하구요. 프론트엔드는 이 응답에 대응해서 사용자가 권한이 없음을 알리거나 (오류 메세지 표시나 로그인 화면으로 리디렉션 하는 방법 등이 있습니다.) 혹은 우아한 방식으로 실패했음을 알리면 됩니다. (비어있거나 '저런!'과 같은 문구가 담긴 템플릿을 렌더링 하면 됩니다. -- 언제 발행되었는지 정해지지 않은 상태로요.)