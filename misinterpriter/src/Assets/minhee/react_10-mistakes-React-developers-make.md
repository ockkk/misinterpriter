# 리액트 개발자들이 하는 10가지 실수들

리액트 어플리케이션을 만드는 개발자들이 흔히 저지르는 실수 몇 가지가 있죠. 이러한 실수는 단순한 부주의나 마감일을 맞춰야 한다는 부담, 또는 리액트/자바스크립트를 사용한 경험이 부족한 탓에 발생합니다. 

이번 포스트에서는 리액트를 다룰 때 개발자들이 종종 겪는 10가지 실수에 대해 다뤄보고자 합니다. 리액트를 기준으로 설명하지만, 이 포스트에서 소개하는 테크닉은 다른 프레임워크를 사용할 때에도 적용할 수 있을 것 같습니다.

*참고: 이 포스트는 리액트를 사용한 경험이 있거나, 잘 이해하고 있는 사람을 위한 글입니다. 만약 리액트를 사용한 경험이 없다면, 공식 도큐멘테이션의 get started를 먼저 보시길 권합니다.*



#### 1. 충분한 갯수의 컴포넌트를 만들지 않는다

리액트 개발자들이 하는 흔한 실수 가운데 하나는 컴포넌트를 충분히 만들지 않는다는 것입니다.

통상적으로 어플리케이션을 만드는 데에는 두 가지 방법이 있습니다. 첫째는 모든 요소를 하나의 파일에 몰아 넣는 것(monolith)이고요, 또는 모든 작은 조각으로 쪼개는 방식(micro-services)입니다.

디자인적 측면에서, 리액트 어플리케이션은 컴포넌트화(componentized)되도록 의도되었습니다. 

![An example of a React dashboard.](https://blog.logrocket.com/wp-content/uploads/2019/09/React-dashboard-nocdn.png)

리액트를 통해 위와 같은 대시보드를 제대로 구축하기 위해서는, 대시보드 전체가 완성된 단일 페이지 그 자체가 아니라, 페이지를 구성하는 여러 컴포넌트들의 집합이라는 이해가 필요합니다. 

이러한 접근 방식을 통해서, 전체 페이지를 구성하는 여러 컴포넌트를 만들 수 있습니다.

여러 컴포넌트를 생성하는 테크닉을 활용한다면 개발 시간을 절약할 수 있을 뿐 아니라, 디버깅 작업을 할 때의 스트레스도 크게 덜 수 있습니다. 애플리케이션이 컴포넌트들로 쪼개져 있기 때문에, 에러가 어떤 컴포넌트와 연관되어 있는지 금세 알아챌 수 있기 때문입니다.



#### 2. 컴포넌트에 로직 작성하기

재사용 가능한 컴포넌트를 만드는 대표적인 방법에는 프레젠테이션 컴포넌트와 컨테이너 컴포넌트 생성 방식이 있습니다. 프레젠테이션 컴포넌트는 보여지는 부분을 담당하고, 컨테이너 컴포넌트에는 작동 로직이 작성되어 있습니다.

리액트 어플리케이션에서 자주 볼 수 있는 실수는 보여지는 부분과 작동 로직을 한 컴포넌트에 작성하는 것입니다. 이런 식으로 컴포넌트를 만든다면, 매번 직접 복사-붙여넣기를 하지 않고서는 컴포넌트나 로직을 재사용하기가 어려울 것입니다.

반면 프레젠테이션 컴포넌트와 컨테이너 컴포넌트 생성 방식을 활용한다면 보여지는 부분과 로직 부분 모두의 재사용성을 높일 수 있습니다. 로직을 망치지 않고도, UI 수정을 쉽게 할 수도 있고요.

아래의 Books 컴포넌트를 살펴 보겠습니다. props로부터 데이터를 받고 보여주는 아주 단순한 기능을 하는 컴포넌트로, 프레젠테이션 컴포넌트의 예시입니다.

```jsx
const Books = props => (
	<ul>
    {props.books.map(book =>(
      <li>{book}</li>
    ))}
  </ul>
)
```

BooksContainer 컴포넌트는 자체적으로 데이터를 관리하고 저장하며, 프레젠테이션 컴포넌트인 Book을 통해 데이터를 페이지에 보여줍니다.

```jsx
class BooksContainer extends React.Component {
  constructor() {
    this.state = {
      books: []
    }
  }

  componentDidMount() {
    axios.get('/books').then(books =>
      this.setState({ books: books }))
    )
  }

  render() {
    return <Books books={this.state.books} />
  }
}
```



#### 3. 스테이트의 변수를 변경하는 것

변이(Mutation)이란 '무언가를 바꿀 수 있는 능력'을 뜻합니다. 다음과 같은 스테이트를 살펴 봅시다.

```js
const person = {
  name: "John",
  sex: "Male"
}
```

person 객체를 바꾸기 위해 새로운 변수를 만들고, 생성한 변수를 person 객체에 할당하면 의도치 못한 결과에 맞딱뜨리게 됩니다.

```js
const newPerson = person

newPerson.name = "Jane"
newPerson.sex = "Female"
```

person과 newPerson 객체를 로그해 보면, 두 객체 모두 가장 최근 값을 보여줍니다. 즉 newPerson 객체 뿐 아니라 person 객체까지 바뀌어 버린 건데요. 이 사례를 통해 컴포넌트의 이해할 수 없는 특징을 확인 할 수 있습니다. 

위와 같은 문제를 해결하기 위해서는, .slice() 메서드나 ES6의 spread operator를 사용해야 합니다.

하지만, 최선의 해결법은 바로 '불변성(immutability)'입니다. 직접(무엇을?ㅋㅋㅋ) 만들거나, 리액트 팀도 추천한 Immutable.js나 immutability-helper를 사용해 보길 권장합니다.



#### 4. 절대 경로를 사용하지 않는 것

여러 개의 컴포넌트와 이미지, CSS 파일 등으로 이루어진 리액트 애플리케이션을 만들어 본 적이 있다면, 각기 다른 디렉토리들로부터 파일을 가져오는(import) 작업이 정말 지루하다는 점에 공감할 겁니다. 보통 많은 개발자들이 다음과 같이 상대 경로 방식으로 파일을 import 해 오는데요,

```js
../../../importone.js
../../../importtwo.js
```

한 눈에 봐도 깔끔함과는 거리가 멉니다. 게다가 파일의 디렉토리가 바뀌면 import가 안 되는 오류가 발생하기도 하죠. 하지만 Create React App3가 출시되면서, 절대 경로를 통해 import를 할 수 있게 되었습니다.

절대 경로를 사용하기 위해서는 루트 디렉토리에 jsconfig.json 파일을 생성하고, 다음 옵션을 작성해야 합니다.

```json
//jsconfig.json
{
  "compilerOptions": {
    "baseUrl": "src"
  },
  "include": ["src"]
}
```

이제는 다음과 같은 방식으로 파일을 가져 올 수 있습니다.

```js
import React from 'react';
import { LINKS } from 'helpers/constants';
import Button from 'components/Button/Button';

function App() {
  return (
    <>
      <Button>
        This is my button
      </Button>

      <a href={LINKS.ABOUT}>About Us</a>
    </>
  );
}
export default App;
```

훨씬 깔끔해졌을 뿐 아니라, 파일의 위치가 변경되어도 경로 코드를 수정할 필요가 없습니다. 😀

#### 5. 리스트 컴포넌트에 key를 사용하지 않음

리액트 애플리케이션을 만들다 보면, 다음 예제 코드와 같이 리스트로 된 항목을 랜더해야 하는 때가 종종 있습니다. 

```jsx
const lists = ['one', 'two', 'three'];

render() {
  return (
    <ul>
      {lists.map(listNo =>
        <li>{listNo}</li>)}
    </ul>
  );
}
```

작은 애플리케이션이라면 키를 생략한 채로 코드를 짜는 게 괜찮을 수도 있습니다. 하지만 규모가 큰 리스트를 랜더링 해야 할 경우, 키가 없으면 리스트 항목을 삭제하거나 수정할 때 문제가 됩니다. 리액트는 DOM에 있는 리스트의 각 엘리먼트를 추적하여 변화를 감지합니다. 때문에 모든 리스트의 엘리먼트에 키를 추가해주어야 합니다.

```jsx
<ul>
  {lists.map(listNo =>
    <li key={listNo}>{listNo}</li>)}
</ul>
```

*참고: ID 또는 고유한 프로퍼티를 통해 배열로 이루어진 객체를 매핑하고, ID를 키로 사용하는 것은 언제나 권장되는 방식입니다.   또한 리액트에서의 키는 고유한 값이어야 합니다. 위에서 보여준 예가 잘 작동하기는 하지만, 단지 샘플 어레이의 엘리먼트들의 값이 서로 다르기 때문입니다.*

**역주: 위 예에서는 키 값으로 배열의 항목을 사용했습니다. 만약 배열에 중복되는 항목이 있다면(ex: ['종옥', '우전', '현서', '현서']) 배열 항목을 키로 사용해서는 안 된다는 이야기인 것 같습니다.

#### 6. 유닛 테스트를 작성하지 않는 것

가장 자주 보이는 실수 가운데 하나입니다. 유닛 테스트 없이도 애플리케이션이 잘 작동하는 것처럼 보일 때가 많기 때문인데요. 

유닛 테스트를 한다면 애플리케이션의 일부를 독립적으로 테스트하여, 특정 기능이 의도대로 작동하는지를 체크 할 수 있습니다.

예를 들어, 컴포넌트가 받는 프롭이 브라우저에 랜더가 되는지 확인하는 유닛 테스트를 작성할 수 있습니다. 왜 그렇게 작은 규모의 테스트를 작성해야 하는지 의아할 수도 있습니다. 하지만 가끔 컴포넌트를 작성을 완료한 후에도, 분명히 나타나야 할 프롭이 제대로 표시되지 않기도 합니다. CSS 스타일의 충돌이 발생해서 해당 요소가 디스플레이 되지 않는 건데요.

유닛 테스트를 작성하면 이와 같은 버그를 즉시 잡아낼 수 있기 때문에, 버그를 찾는데 걸리는 시간을 절약할 수 있습니다. 다시 말해, 애플리케이션을 빠르게 디버깅하는데에 큰 도움이 됩니다.

#### 7. Prop-types를 사용하지 않는 것

잘못된 데이터 타입이 전달되는 경우도 흔히 보이는 실수입니다. 예를 들어, props를 통해 숫자 2를 다른 컴포넌트에 전달하고자 한다고 가정해 봅시다.  

```jsx
<MyComponent value="2" />
```

이렇게 된다면, MyComponent에는 숫자 2가 아닌 문자 2가 전달이 됩니다. 숫자 형태로 전달하기 위해서는 다음과 같이 수정해야 하죠.

```jsx
<MyComponent value={2}>
```

Prop-types 패키지를 사용하여 데이터 타입을 정의한다면 우리가 원하는 바와 맞는 타입의 props을 걱정 없이 전달할 수 있습니다.

Prop-types를 통해, 컴포넌트에 전달하고자 하는 프로퍼티가 어떤 타입이어야 하는지 정의할 수 있습니다. 리액트는 컴포넌트에 전달된 props가 우리의 의도에 부합하는지 확인을 해 줍니다. 만약 일치하지 않는다면 경고를 표시합니다.

Prop-type에 대해서 더욱 자세히 알고 싶다면, 공식 레포지토리(https://github.com/facebook/prop-types)를 참고해 주세요.

#### 8. 헬퍼 클래스 또는 함수를 사용하지 않는 것.

이 또한 자주 볼 수 있는 실수입니다. 보통 리액트 애플리케이션들은 재사용 가능한 컴포넌트 뿐 아니라, 재사용 가능한 함수 또한 포함하고 있습니다. 재사용 가능한 함수들을 개별 컴포넌트마다 하드코딩 해버리는 경우가 많은데, 이는 컴포넌트들의 일관성과 효율성을 떨어트리는 결과를 초래합니다.

대다수의 컨테이너 컴포넌트들은 데이터 리소스를 가져오고, 스테이트에 저장하며, 에러를 관리하는 로직을 가지고 있습니다. 다시 말해, 웬만한 컨테이너 컴포넌트들은 동일한 방식으로 동작합니다. 하지만 잘못 작성된 코드에서는, 비슷한 기능을 공유하는 컴포넌트들이 일관적이지 않은 로직을 가지게 됩니다. **역주: 개별 컴포넌트에 비슷비슷한 함수들이 하드코딩이 되어 있기 때문입니다..

여러 컴포넌트들이 공유하는 기능의 로직을 헬퍼 클래스나 함수로 빼 놓는다면, 해당 로직을 각기 다른 컴포넌트에서 여러 번 재사용 할 수 있을 것입니다.

#### 9. 애플리케이션의 모든 스테이트를 리덕스나 플럭스를 통해 관리하는 것

큰 규모의 리액트 애플리케이션을 만드는 경우, 대다수의 개발자들이 리덕스 또는 플럭스를 사용하여 글로벌 스테이트를 관리합니다. 애플리케이션의 여러 부분들이 하나의 스테이트를 공유해야 할 경우에는 아주 좋은 전략입니다.

하지만, 리덕스/플럭스를 통해 애플리케이션의 모든 상태를 관리하는 것은 권유하고 싶지 않습니다.

폼 컴포넌트를 예로 들어 보겠습니다. 만약 폼 컴포넌트가 뜰 때마다, 체크박스가 항상 체크되어 있는 상태이길 바란다면, 리덕스나 플럭스를 도입하기 보다는 local state를 쓰거나 useState(Hooks의 경우)를 사용하는 것이 더 낫습니다.

**역주: 좀 모호한 것 같은데, 작은 규모의 앱일 경우 굳이 리덕스나 플럭스를 쓸 필요 없다는 이야기인 것 같아요.

#### 10. 리액트/리덕스 개발자 도구를 사용하지 않는 것

어플리케이션에서 버그는 필연적으로 발생하기 마련입니다. 보통 많은 컴포넌트를 다루어야 하기 때문에, 디버깅도 절대 간단한 작업은 아닌데요.

리액트 개발자 도구를 사용하면 리액트 엘리먼트의 랜더링된 트리를 검사할 수 있습니다. 다양한 컴포넌트들이 페이지를 구성하고 있는 형태를 체크하는 데 매우 유용합니다.

리덕스 개발자 도구를 통해서는 발생한 액션들을 확인하고, 어떤 액션의 결과로 일어난 스테이트의 변화를 볼 수 있으며, 또한 특정한 액션이 발생하기 전으로 되돌릴 수도 있습니다.

리액트 개발자 도구는 dev dependency 또는 브라우저 확장 프로그램에 추가할 수 있습니다. 개발자 도구를 사용하여 개발에 드는 시간을 절약해 보세요.

#### 결론

이 포스트에서는 리액트 개발자들이 애플리케이션을 만들 때 자주 겪는 실수를 다루어 보았습니다. 앱 개발 과정을 더 효과적으로, 또 덜 힘들게 만들어주는 접근 방법과 툴에 대해서도 알려 드렸습니다.

리액트 개발 중에 흔히 저지르는 실수에 대한 다른 조언이 있다면 댓글로 공유해 주시길 바랍니다.

출처: https://blog.logrocket.com/10-mistakes-react-developers-make/