## JWT와 리액트 라우터를 사용하여 리액트 앱을 보호하는 간단한 방법

### 앱 구현에 있어, 앱의 특정 부분을 보호하는 것은 중요한 작업입니다. 이 포스트에서는 이와 관련된 두 가지 차원에 대해 다뤄 보겠습니다.

리액트 앱을 보호하는 작업에는 두 차원이 있습니다.

- API 차원, 유저가 바꾸거나 읽을 수 있는 데이터
- 리액트 차원, 유저가 접근할 수 있는 리액트 앱 경로

데이터 보호는 매우 중요한 작업입니다. 리액트 앱에 버그가 발생하여, 원래는 접근해서는 안 될 곳에 유저가 접근할 수 있다면, API는 어떠한 데이터도 리턴해서는 안 됩니다. 다시 말해, 리액트 차원에서 인증 관리에 결함이 있더라도 API의 인증 체계는 잘 돌아가고 있다면, 유저는 데이터가 없는 화면을 보게 될 것입니다.

이번 포스트에서는 애플리케이션의 클라이언트 측에 초점을 맞추어, 두 계층, 즉 API와 리액트 차원에서의 보안에 대해 이야기해보자 합니다.



### 세션 스테이트

REST 또는 GraphQL 가운데 어떤 것을 API로 사용하던 간에, 여러분의 앱은 HTTP 프로토콜을 통해 작동하게 됩니다. 프로토콜 차원에서 여러분의 API는 스테이트가 없는(stateless) 상태입니다.

유저 권한을 승인하려면 유저를 추적해야 합니다. 클라이언트/서버 애플리케이션에서 세션 상태를 유지하기 위한 방법에는 두 가지가 있습니다.

- 첫째는 **서버에 세션 상태를 저장**하는 방식입니다. 유저의 권한을 더욱 잘 제어할 수 있지만, 클라이언트가 많을수록 세션을 저장하는 리소스를 더 많이 할당해야 하므로 확장성이 떨어집니다.
- 두 번째는 **클라이언트에 세션 상태를 저장**하는 것입니다. 이 경우 클라이언트가 많아진다고 해서 리소스에 영향을 주지 않습니다. 각 클라이언트들이 스테이트를 나누어 갖기 때문입니다. 덕분에 확장성은 크지만, 유저 권한에 대한 제어력이 비교적 떨어집니다.

모든 상황에 적합한 단 한 가지 정답이 있지는 않습니다. 개발자들에 있어 중요한 임무는, 단순히 어떤 툴을 개발에 적용하는 일이 아니라, 상황에 따라 올바른 결정을 내리는 것이라 생각합니다. 대다수 개발자들은 스테이트가 없는 서버를 사용함으로서, 유저에 대한 제어 능력을 어느 정도 포기하는 대신 개발에서의 단순함을 얻을 수 있다고 생각합니다. 하지만 이 또한 모든 앱 개발 시나리오에 공통적으로 적용되지는 않을 것입니다.

그래서, 클라이언트 측에서의 스테이트는 어떻게 동작하는 것일까요? 핵심은 암호화입니다. 클라이언트는 스테이트를 저장할 것이고, 서버는 클라이언트에 있는 세션이 유효한지 확인하는 (프라이빗한) 키를 가질 것입니다. 이러한 구조를 구축하기 위해 JWT를 이용해 봅시다. 

### JWT

JWT(JSON Web Token)은 두 당사자 간의 요청을 안전하게 표현하기 위한 개방형 산업 표준 RFC 7519 방식입니다.

이 글에서는 JWT에 대해 자세히 다루지는 않을 예정입니다. 하지만 본격적으로 시작하기 전에, JWT와 관련한 몇 가지 핵심 사항을 살펴보도록 하겠습니다.

- 토큰은 `user_id` 또는 `username`과 같은 정보를 담을 수 있습니다. 이러한 정보는 클라이언트에 저장되고, 서버를 통해 공유됩니다.

- 토큰의 데이터는 ''서명되어'' 있습니다. 즉 데이터가 변경된 줄 모른채 바뀔 수는 없다는 뜻입니다. 이러한 방식으로, 클라이언트는 '내가 사용자 X다'는 것을 나타낼 수 있습니다.

  (역주: 이 부분의 의미가 불투명합니다. 혹시 읽으시면서 이게 어떤 의미일지 함께 생각해 주시면 매우 감사하겠습니다. 😹  원문 첨부합니다.

  > The data in the token is signed. This means, the data can’t be changed without knowing it was altered. This way a client can claim “I’m user X”.

  제 추측으로는, (클라이언트가 아니라) 서버가 토큰의 데이터를 바꿔야만 토큰 데이터가 바뀐다는 의미인 것 같습니다.)

- 토큰의 데이터는 프라이빗하지 않습니다. 즉 데이터가 공개되어 있으며, 누구든 읽을 수 있습니다(방금 언급했듯이, 서버가 토큰의 데이터를 바꿀 수는 있습니다). 따라서 이메일이나 신용카드 정보 등과 같은 프라이빗한 데이터를 토큰에 보관해서는 안 됩니다.

[JWT 웹사이트](https://jwt.io/)에서는 디버거를 제공합니다. 디버거에 토큰을 붙여넣기하여 내용을 살펴볼 수 있습니다. 웹사이트에 접속하셔서, 디버거를 직접 만져 보시기를 권합니다. 

### 클라이언트에 스테이트를 저장하기

지금까지 JWT에 대해 살펴보았습니다. 이제는 클라이언트의 어디에 토큰을 저장해야 할지에 관해 이야기해 봅시다. 일반적으로 웹앱에서는 i) 로컬 스토리지 또는 ii) 쿠키에 토큰을 저장할 수 있습니다. 서버와 클라이언트가 같은 도메인 또는 서브 도메인을 사용하고 있다면, 로컬 스토리지보다는 쿠키를 추천합니다. 쿠키를 사용한다면, 앱에서 별도로 토큰을 관리할 필요가 없기 때문입니다. 토큰이 브라우저 단계에서 관리되기 때문에 보안상에서의 버그가 발생할 가능성 또한 줄어듭니다.

결국, 토큰을 저장하는 곳을 결정하는 것은 구현 상의 디테일과 관련이 있습니다. 리액트 사용법을 익히는 수업에서는 단순함을 위해서 쿠키를 사용할 것을 권장합니다. 브라우저에서 토큰을 관리하기 때문에, 코드 작성량이 줄어들어 수업을 더 빠르게 진행할 수 있거든요.

일단 첫 번째 파트, 데이터 보호는 끝났습니다. 데이터 보호를 위해 리액트 앱에서 추가적으로 할 일이 있냐고요? 없습니다! 쿠키 설정은 API에서 이루어지며, 데이터를 반환하거나 수정하는 모든 요청들을 처리하기 전에 쿠키를 조회하고 인증하는 작업 또한 API가 담당합니다. 정말 간단하고 신속한 과정입니다. 쿠키 덕분에, 토큰이 리액트 앱이 아니라 브라우저에 의해 관리되기 때문입니다.

### 인증(Authentication) vs 권한 부여(Authorization)

인증(authentication)은 주어진 유저와 세션을 일치시키는 행위를 뜻합니다. 가령, 주어진 세션을 통해 사용자가 `user_id 123`인지 확실하게 식별하는 것이 인증입니다.

반면 권한 부여(Authorization)는 유저가 특정한 리소스에 접근할 수 있는지를 판단하는 행위입니다. 두 명의 유저가 있고, 관리자와 슈퍼-관리자가 있다고 가정해 봅시다. 관리자는 청구서를 조회할 수 있지만, 삭제할 수는 없습니다. 슈퍼-관리자는 청구서를 읽고 삭제까지 할 수 있습니다.

정리하자면, 권한 부여 전에 인증이 먼저 이루어져야 합니다.

인증은, 유저가 앱의 여러 리소스들에 접근할 때 필요한, 유효한 토큰을 획득하는 메커니즘을 통해 이루어집니다. 일반적으로 이러한 과정은 API에 자격 증명(e.g. 사용자 이름, 비밀번호 등)을 제출하는 방식으로 이루어집니다. 

### 클라이언트의 라우트 보호

특정 세션이 액세스 할 수 있는 뷰를 리액트 코드를 통해 처리하는 작업에 대해 다뤄 보겠습니다. 앞서 이야기했듯, API 차원에서 데이터를 보호하고 있기 때문에, 리액트 차원에서는 추가적인 보안 보다는 더 나은 유저 경험을 제공하는 데 중점을 두어야 합니다.

다시 말해 리액트 앱은 현재 세션에서는 접근할 수 없는 페이지를 사용자에게 보여주지 않도록 처리해 주어야 합니다. 

공개된 라우트와 숨겨진 라우트로 이루어진 웹사이트가 있다고 가정해 봅시다. 유저가 인증 과정을 거치지 않았다면 로그인 페이지로 리다이렉트 해 주고, 인증 과정을 거쳤다면 앱을 보여주어야 합니다. 

![img](https://miro.medium.com/max/1600/0*Md-bM55KYMJtVF5Q)

이러한 기능은 컴포넌트의 루트 단계에 조건문을 추가해 줌으로써 쉽게 구현할 수 있습니다. 만약 조건(e.g. 유효한 토큰이 있는지?)이 참이면 `<App />` 가지를 랜더하게 될 것입니다. 

![img](https://miro.medium.com/max/1600/0*kVgnDXxgaA_d_Y80)

다음은 리액트 컴포넌트에서 조건부 랜더링을 구현하는 예시입니다.

```jsx
<Route path="/" render={(=>(
  getSession() ? (
  <App to="/"/>
  ) : (
  <Redirect to="/login/">
  )
)}/>
```

위의 예제에서는 리다이렉트 컴포넌트에 대해 살펴보았습니다. 리다이렉트 컴포넌트는 유저를 다른 경로로 보내는 선언적인(declarative) 방식입니다. 리다이렉트 컴포넌트 내부에서 `history.push(path)`와 같은 동작을 실행하는 것이지요. 리액트 컴포넌트는 선언적으로 작동할 수 있도록, 몇 가지 유용한 코드를 캡슐화하여 가지고 있습니다. 유의할 점은, 리액트는 선언적인 구조를 권장하고 있다는 것입니다. 따라서 `history.push(path)`보다는 선언적 형태를 사용하는 것이 좋겠습니다.

쿠키를 사용하여 JWT를 저장하고 있는 경우, 위 예제의 `getSession` 함수는 다음과 같이 구현 수 있습니다.

```jsx
import Cookies from 'js-cookie'
export const getSession = () => {
  const jwt = Cookies.get('__session')
  let session
  try {
    if (jwt) {
      const base64Url = jwt.split('.')[1]
      const base64 = base64Url.replace('-', '+').replace('_', '/')
      // what is window.atob ?
      // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/atob
      session = JSON.parse(window.atob(base64))
    }
  } catch (error) {
    console.log(error)
  }
  return session
}
export const logOut = () => {
  Cookies.remove('__session')
}
```

만약 애플리케이션에 퍼블릭하거나 프라이빗한 라우트들이 여러 개 있다면, 앞의 예시에서와 같이 리다이렉션을 처리할 수 있는 일반적인 컴포넌트를 하나 만들 수 있습니다. 다음은 리액트 라우터 공식 도큐멘테이션에서 가져온 예시입니다.

```jsx
function PrivateRoute({ component: Component, ...rest }) {
  return (
    <Route
      {...rest}
      render={props =>
        fakeAuth.isAuthenticated ? (
          <Component {...props} />
        ) : (
          <Redirect
            to={{
              pathname: "/login",
              state: { from: props.location }
            }}
          />
        )
      }
    />
  );
}
```

로그인해야만 볼 수 있는 경로로 접근한 유저를 로그인 페이지로 보내기 위해 `PrivateRoute`를 사용할 수 있습니다. 다음 예시를 봅시다.

```jsx
import { Switch, Route } from "react-router-dom"
import ProtectedRoute from "./ProtectedRoute"
// other required imports like Auth, Onboarding, etc
// some component wrapping this return ...
return (
    <Switch>
        <Route path="/auth" component={Auth} />
        <Route path="/onboarding" component={Onboarding} />
        <ProtectedRoute
        path="/customer-error/"}
        component={ExistingCustomerError}
        />
        <ProtectedRoute
        path="/discrete-loan"
        component={DiscreteLoan}
        />
        <Route component={NotFound} />
    <Switch>
)
```

### 정리하자면...

- 유저 세션을 클라이언트 또는 서버에 저장할 수 있습니다. 서버에 저장한다면 세션에 대한 통제가 강화되지만, 확장성은 줄어듭니다. 반대로 클라이언트에 저장한다면 확장성은 커지고 통제력은 줄어듭니다.
- JWT는 스테이트를 클라이언트에 저장하기 위한 최선의 방식입니다. JWT는 보호되지만, 페이로드는 누구든 조회할 수 있다는 점 또한 유의해 주세요.
- 클라이언트에서, 로컬 스토리지 또는 쿠키를 이용하여 세션을 저장할 수 있습니다. 쿠키는 브라우저가 관리하기 때문에, 앱에서의 작업이 줄어들 뿐 아니라 안전성도 더욱 높아집니다.
- API와 프론트앤드가 같은 도메인/서브도메인 상에 있다면 쿠키를 사용하여 토큰을 저장할 수 있습니다.
- 리액트 라우터의 리다이렉트 컴포넌트와 조건부 랜더링을 함께 사용하여, 리액트 앱에서 라우트 보호를 더욱 쉽게 구현할 수 있습니다. 

